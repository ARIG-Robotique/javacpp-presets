// Targeted by JavaCPP version 1.3.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class rplidar extends org.bytedeco.javacpp.presets.rplidar {
    static { Loader.load(); }

// Parsed from <rplidar.h>

/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// #pragma once

// #include "rptypes.h"
// #include "rplidar_protocol.h"
// #include "rplidar_cmd.h"

// #include "rplidar_driver.h"

public static final String RPLIDAR_SDK_VERSION =  "1.5.7";


// Parsed from <rplidar_cmd.h>

/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// #pragma once

// #include "rplidar_protocol.h"

// Commands
//-----------------------------------------

// Commands without payload and response
public static final int RPLIDAR_CMD_STOP =               0x25;
public static final int RPLIDAR_CMD_SCAN =               0x20;
public static final int RPLIDAR_CMD_FORCE_SCAN =         0x21;
public static final int RPLIDAR_CMD_RESET =              0x40;


// Commands without payload but have response
public static final int RPLIDAR_CMD_GET_DEVICE_INFO =    0x50;
public static final int RPLIDAR_CMD_GET_DEVICE_HEALTH =  0x52;

public static final int RPLIDAR_CMD_GET_SAMPLERATE =     0x59; //added in fw 1.17

// Commands with payload and have response
public static final int RPLIDAR_CMD_EXPRESS_SCAN =       0x82; //added in fw 1.17

//add for A2 to set RPLIDAR motor pwm when using accessory board
public static final int RPLIDAR_CMD_SET_MOTOR_PWM =      0xF0;
public static final int RPLIDAR_CMD_GET_ACC_BOARD_FLAG = 0xFF;

// #if defined(_WIN32)
// #pragma pack(1)
// #endif


// Payloads
// ------------------------------------------
public static final int RPLIDAR_EXPRESS_SCAN_MODE_NORMAL =      0; 
public static final int RPLIDAR_EXPRESS_SCAN_MODE_FIXANGLE =    1;

public static final int MAX_MOTOR_PWM =               1023;
public static final int DEFAULT_MOTOR_PWM =           660;

// Response
// ------------------------------------------
public static final int RPLIDAR_ANS_TYPE_DEVINFO =          0x4;
public static final int RPLIDAR_ANS_TYPE_DEVHEALTH =        0x6;

public static final int RPLIDAR_ANS_TYPE_MEASUREMENT =                0x81;
// Added in FW ver 1.17
public static final int RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED =       0x82;

// Added in FW ver 1.17
public static final int RPLIDAR_ANS_TYPE_SAMPLE_RATE =      0x15;

public static final int RPLIDAR_ANS_TYPE_ACC_BOARD_FLAG =   0xFF;

public static final int RPLIDAR_RESP_ACC_BOARD_FLAG_MOTOR_CTRL_SUPPORT_MASK =      (0x1);


public static final int RPLIDAR_STATUS_OK =                 0x0;
public static final int RPLIDAR_STATUS_WARNING =            0x1;
public static final int RPLIDAR_STATUS_ERROR =              0x2;

public static final int RPLIDAR_RESP_MEASUREMENT_SYNCBIT =        (0x1<<0);
public static final int RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT =  2;
public static final int RPLIDAR_RESP_MEASUREMENT_CHECKBIT =       (0x1<<0);
public static final int RPLIDAR_RESP_MEASUREMENT_ANGLE_SHIFT =    1;

//[distance_sync flags]
public static final int RPLIDAR_RESP_MEASUREMENT_EXP_ANGLE_MASK =           (0x3);
public static final int RPLIDAR_RESP_MEASUREMENT_EXP_DISTANCE_MASK =        (0xFC);   


public static final int RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1 =               0xA;
public static final int RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2 =               0x5;

public static final int RPLIDAR_RESP_MEASUREMENT_EXP_SYNCBIT =              (0x1<<15);

// #if defined(_WIN32)
// #pragma pack()
// #endif


// Parsed from <rplidar_driver.h>

/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// #pragma once


// #ifndef __cplusplus
// #error "The RPlidar SDK requires a C++ compiler to be built"
// #endif

@Namespace("rp::standalone::rplidar") public static class RPlidarDriver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RPlidarDriver(Pointer p) { super(p); }

    /** enum rp::standalone::rplidar::RPlidarDriver:: */
    public static final int
        DEFAULT_TIMEOUT = 2000; //2000 ms

    /** enum rp::standalone::rplidar::RPlidarDriver:: */
    public static final int
        DRIVER_TYPE_SERIALPORT =  0x0;
    /** Create an RPLIDAR Driver Instance
     *  This interface should be invoked first before any other operations
     * 
     *  @param drivertype the connection type used by the driver.  */
    public static native RPlidarDriver CreateDriver(@Cast("_u32") int drivertype/*=rp::standalone::rplidar::RPlidarDriver::DRIVER_TYPE_SERIALPORT*/);
    public static native RPlidarDriver CreateDriver();

    /** Dispose the RPLIDAR Driver Instance specified by the drv parameter
     *  Applications should invoke this interface when the driver instance is no longer used in order to free memory */
    public static native void DisposeDriver(RPlidarDriver drv);
    /** Open the specified serial port and connect to a target RPLIDAR device
     * 
     *  @param port_path     the device path of the serial port 
     *         e.g. on Windows, it may be com3 or \\.\com10 
     *              on Unix-Like OS, it may be /dev/ttyS1, /dev/ttyUSB2, etc
     * 
     *  @param baudrate      the baudrate used
     *         For most RPLIDAR models, the baudrate should be set to 115200
     * 
     *  @param flag          other flags
     *         Reserved for future use, always set to Zero */
    public native @Cast("u_result") int connect(@Cast("const char*") BytePointer port_path, @Cast("_u32") int baudrate, @Cast("_u32") int flag/*=0*/);
    public native @Cast("u_result") int connect(@Cast("const char*") BytePointer port_path, @Cast("_u32") int baudrate);
    public native @Cast("u_result") int connect(String port_path, @Cast("_u32") int baudrate, @Cast("_u32") int flag/*=0*/);
    public native @Cast("u_result") int connect(String port_path, @Cast("_u32") int baudrate);


    /** Disconnect with the RPLIDAR and close the serial port */
    public native void disconnect();

    /** Returns TRUE when the connection has been established */
    
    ///
    public native @Cast("bool") boolean isConnected();

    /** Ask the RPLIDAR core system to reset it self
     *  The host system can use the Reset operation to help RPLIDAR escape the self-protection mode.
     *  */
    //  \param timeout       The operation timeout value (in millisecond) for the serial port communication                     
    
    ///
    ///
    public native @Cast("u_result") int reset(@Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int reset();

    /** Retrieve the health status of the RPLIDAR
     *  The host system can use this operation to check whether RPLIDAR is in the self-protection mode.
     * 
     *  @param health        The health status info returned from the RPLIDAR
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication      */
    
    ///
    public native @Cast("u_result") int getHealth(@ByRef rplidar_response_device_health_t health, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int getHealth(@ByRef rplidar_response_device_health_t health);

    /** Get the device information of the RPLIDAR include the serial number, firmware version, device model etc.
     *  
     *  @param info          The device information returned from the RPLIDAR
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication   */
    
    ///
    public native @Cast("u_result") int getDeviceInfo(@ByRef rplidar_response_device_info_t info, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int getDeviceInfo(@ByRef rplidar_response_device_info_t info);

    /** Get the sample duration information of the RPLIDAR.
     *  
     *  @param rateInfo      The sample duration information returned from the RPLIDAR
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication */
    public native @Cast("u_result") int getSampleDuration_uS(@ByRef rplidar_response_sample_rate_t rateInfo, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int getSampleDuration_uS(@ByRef rplidar_response_sample_rate_t rateInfo);
    
    /** Set the RPLIDAR's motor pwm when using accessory board, currently valid for A2 only.
     *  
     *  @param pwm           The motor pwm value would like to set  */
    public native @Cast("u_result") int setMotorPWM(@Cast("_u16") short pwm);

    /** Start RPLIDAR's motor when using accessory board */
    public native @Cast("u_result") int startMotor();

    /** Stop RPLIDAR's motor when using accessory board */
    
    ///
    public native @Cast("u_result") int stopMotor();

    /** Check whether the device support motor control.
     *  Note: this API will disable grab.
     *  
     *  @param support       Return the result.
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication.  */
    
    ///
    ///
    ///
    ///
    public native @Cast("u_result") int checkMotorCtrlSupport(@Cast("bool*") @ByRef BoolPointer support, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int checkMotorCtrlSupport(@Cast("bool*") @ByRef BoolPointer support);
    public native @Cast("u_result") int checkMotorCtrlSupport(@Cast("bool*") @ByRef boolean[] support, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int checkMotorCtrlSupport(@Cast("bool*") @ByRef boolean[] support);

    /** Calcuate RPLIDAR's current scanning frequency from the given scan data
     *  Please refer to the application note doc for details
     *  Remark: the calcuation will be incorrect if the specified scan data doesn't contains enough data
     * 
     *  @param inExpressMode Indicate whether the RPLIDAR is in express mode
     * 
     *  @param count         The number of sample nodes inside the given buffer
     * 
     *  @param frequency     The scanning frequency (in HZ) calcuated by the interface.
     * 
     *  @param is4kmode      Return whether the RPLIDAR is working on 4k sample rate mode. */
    
    ///
    ///
    ///
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef FloatPointer frequency, @Cast("bool*") @ByRef BoolPointer is4kmode);
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef FloatBuffer frequency, @Cast("bool*") @ByRef boolean[] is4kmode);
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef float[] frequency, @Cast("bool*") @ByRef BoolPointer is4kmode);
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef FloatPointer frequency, @Cast("bool*") @ByRef boolean[] is4kmode);
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef FloatBuffer frequency, @Cast("bool*") @ByRef BoolPointer is4kmode);
    public native @Cast("u_result") int getFrequency(@Cast("bool") boolean inExpressMode, @Cast("size_t") long count, @ByRef float[] frequency, @Cast("bool*") @ByRef boolean[] is4kmode);

    /** Ask the RPLIDAR core system to enter the scan mode(Normal/Express, Express mode is 4k mode)
     *  A background thread will be created by the RPLIDAR driver to fetch the scan data continuously.
     *  User Application can use the grabScanData() interface to retrieved the scan data cached previous by this background thread.
     * 
     *  @param force         Force the core system to output scan data regardless whether the scanning motor is rotating or not.
     * 
     *  @param autoExpressMode Force the core system to trying express mode first, if the system does not support express mode, it will use normal mode.
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication. */
    public native @Cast("u_result") int startScan(@Cast("bool") boolean force/*=false*/, @Cast("bool") boolean autoExpressMode/*=true*/);
    public native @Cast("u_result") int startScan();
    public native @Cast("u_result") int startScanNormal(@Cast("bool") boolean force, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int startScanNormal(@Cast("bool") boolean force);
    
    ///
    public native @Cast("u_result") int startScanExpress(@Cast("bool") boolean fixedAngle, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int startScanExpress(@Cast("bool") boolean fixedAngle);

    /** Check whether the device support express mode.
     *  
     *  @param support       Return the result.
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication. */
    
    ///
    public native @Cast("u_result") int checkExpressScanSupported(@Cast("bool*") @ByRef BoolPointer support, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int checkExpressScanSupported(@Cast("bool*") @ByRef BoolPointer support);
    public native @Cast("u_result") int checkExpressScanSupported(@Cast("bool*") @ByRef boolean[] support, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int checkExpressScanSupported(@Cast("bool*") @ByRef boolean[] support);

    /** Ask the RPLIDAR core system to stop the current scan operation and enter idle state. The background thread will be terminated
     * 
     *  @param timeout       The operation timeout value (in millisecond) for the serial port communication  */
    
    ///
    ///
    ///
    ///
    ///
    ///
    public native @Cast("u_result") int stop(@Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
    public native @Cast("u_result") int stop();


    /** Wait and grab a complete 0-360 degree scan data previously received. 
     *  The grabbed scan data returned by this interface always has the following charactistics:
     * 
     *  1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1
     *  2) All data nodes are belong to exactly ONE complete 360-degrees's scan
     *  3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.
     * 
     *  @param nodebuffer     Buffer provided by the caller application to store the scan data
     * 
     *  @param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
     *                        Once the interface returns, this parameter will store the actual received data count.
     * 
     *  @param timeout        Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.
     * 
     *  The interface will return RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration. 
     * 
     *  \The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation. */
	
	///
	///
	public native @Cast("u_result") int grabScanData(rplidar_response_measurement_node_t nodebuffer, @Cast("size_t*") @ByRef SizeTPointer count, @Cast("_u32") int timeout/*=rp::standalone::rplidar::RPlidarDriver::DEFAULT_TIMEOUT*/);
	public native @Cast("u_result") int grabScanData(rplidar_response_measurement_node_t nodebuffer, @Cast("size_t*") @ByRef SizeTPointer count);

    /** Ascending the scan data according to the angle value in the scan.
     * 
     *  @param nodebuffer     Buffer provided by the caller application to do the reorder. Should be retrived from the grabScanData
     * 
     *  @param count          The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t).
     *                        Once the interface returns, this parameter will store the actual received data count.
     *  The interface will return RESULT_OPERATION_FAIL when all the scan data is invalid.  */
    public native @Cast("u_result") int ascendScanData(rplidar_response_measurement_node_t nodebuffer, @Cast("size_t") long count);
}





// Parsed from <rplidar_protocol.h>

/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// #pragma once

// RP-Lidar Input Packets

public static final int RPLIDAR_CMD_SYNC_BYTE =        0xA5;
public static final int RPLIDAR_CMDFLAG_HAS_PAYLOAD =  0x80;


public static final int RPLIDAR_ANS_SYNC_BYTE1 =       0xA5;
public static final int RPLIDAR_ANS_SYNC_BYTE2 =       0x5A;

public static final int RPLIDAR_ANS_PKTFLAG_LOOP =     0x1;

public static final int RPLIDAR_ANS_HEADER_SIZE_MASK =        0x3FFFFFFF;
public static final int RPLIDAR_ANS_HEADER_SUBTYPE_SHIFT =    (30);

// #if defined(_WIN32)
// #pragma pack(1)
// #endif

// #if defined(_WIN32)
// #pragma pack()
// #endif


// Parsed from <rptypes.h>

/*
 *  RPLIDAR SDK
 *
 *  Copyright (c) 2009 - 2014 RoboPeak Team
 *  http://www.robopeak.com
 *  Copyright (c) 2014 - 2016 Shanghai Slamtec Co., Ltd.
 *  http://www.slamtec.com
 *
 */
/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// #pragma once


// #ifdef _WIN32

//fake stdint.h for VC only

// #else

// #include <stdint.h>

// #endif


//based on stdint.h

// #define __small_endian

// #ifndef __GNUC__
// #define __attribute__(x)
// #endif


// The _word_size_t uses actual data bus width of the current CPU
// #ifdef _AVR_
// #define THREAD_PROC    
// #elif defined (WIN64)
// #define THREAD_PROC    __stdcall
// #elif defined (WIN32)
// #define THREAD_PROC    __stdcall
// #elif defined (__GNUC__)
// #define THREAD_PROC   
// #elif defined (__ICCARM__)
// #define THREAD_PROC  
// #endif

public static final int RESULT_OK =              0;
public static final int RESULT_FAIL_BIT =        0x80000000;
public static final int RESULT_ALREADY_DONE =    0x20;
public static final int RESULT_INVALID_DATA =    (0x8000 | RESULT_FAIL_BIT);
public static final int RESULT_OPERATION_FAIL =  (0x8001 | RESULT_FAIL_BIT);
public static final int RESULT_OPERATION_TIMEOUT =  (0x8002 | RESULT_FAIL_BIT);
public static final int RESULT_OPERATION_STOP =    (0x8003 | RESULT_FAIL_BIT);
public static final int RESULT_OPERATION_NOT_SUPPORT =    (0x8004 | RESULT_FAIL_BIT);
public static final int RESULT_FORMAT_NOT_SUPPORT =    (0x8005 | RESULT_FAIL_BIT);
public static final int RESULT_INSUFFICIENT_MEMORY =   (0x8006 | RESULT_FAIL_BIT);

// #define IS_OK(x)    ( ((x) & RESULT_FAIL_BIT) == 0 )
// #define IS_FAIL(x)  ( ((x) & RESULT_FAIL_BIT) )

public static class thread_proc_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    thread_proc_t(Pointer p) { super(p); }
    protected thread_proc_t() { allocate(); }
    private native void allocate();
    public native @Cast("_word_size_t") byte call( Pointer arg0 );
}


}
